
/**
 * 
 * 
 * ^ 匹配开头
 * $ 匹配结尾
 * [A-Z] 匹配大写字母
 * [a-z] 匹配小写字母
 * [\d] 匹配一个数字，相当于[0-9]
 * [\W] 匹配数字、字母、下划线以外的所有字符，相当于[^A-Za-z0-9_]
 * . 匹配除换行符（\n \r）之外的任何字符
 * {8,20} 匹配8-20个字符
 * + 匹配前面的子表达式一次或多次
 * [?!pattern] 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。
 *             这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
 *             例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。
 *             例如：(?![A-Z]+) 中，pattern 是[A-Z]+$，意思是[A-Z]+$用来匹配所有字符均为大写字母，
 *             加上^匹配开头，如果一个字符串全是大写字母，前者匹配到的就是个空，即false，
 *             如果字符串不全是大写字母，匹配到的就是非大写字母的字符的位置，即为true
 * /^(?![A-Z]+$)(?![a-z]+$)(?!\d+$)(?![\W_]+$).{8,20}$/ 
 * 上式的意思就是，
 * 全是大写字母会被/^(?![A-Z]+$)/匹配到false
 * 全是小写字母会被/^(?![a-z]+$)/匹配到false
 * 全是数字会被/^(?!\d+$)/匹配到false
 * 全是特殊字符会被/^(?![\W_]+$)/匹配到false
 * 走到.{8,20}，匹配8-20位满足上述条件后的字符
 * 
 */


// 密码格式，必须包含大小写字母、数字、特殊字符中的2个以上，8-12位
const fn = (e) => {
  const pat = /^(?![A-Z]+$)(?![a-z]+$)(?!\d+$)(?![\W_]+$).{8,20}$/
  return pat.test(e)
}

export default {
  fn
}
